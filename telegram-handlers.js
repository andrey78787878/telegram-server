const axios = require('axios');
const FormData = require('form-data');

const BOT_TOKEN = process.env.BOT_TOKEN;
const TELEGRAM_API = `https://api.telegram.org/bot${BOT_TOKEN}`;
const TELEGRAM_FILE_API = `https://api.telegram.org/file/bot${BOT_TOKEN}`;
const GAS_WEB_APP_URL = process.env.GAS_WEB_APP_URL;

// –ü—Ä–∞–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
const MANAGERS = ['@EvelinaB87', '@Andrey_Tkach_MB', '@Davr_85'];
const EXECUTORS = ['@EvelinaB87', '@Olim19', '@Oblayor_04_09', '@Andrey_Tkach_MB', '@Davr_85'];
const AUTHORIZED_USERS = [...new Set([...MANAGERS, ...EXECUTORS])];

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
function extractRowFromCallbackData(callbackData) {
  if (!callbackData) return null;
  const parts = callbackData.split(':');
  return parts.length > 2 ? parseInt(parts[2], 10) : null;
}

function extractRowFromMessage(text) {
  if (!text) return null;
  const match = text.match(/#(\d+)/);
  return match ? parseInt(match[1], 10) : null;
}

function parseRequestMessage(text) {
  if (!text) return null;
  
  const result = {};
  const lines = text.split('\n');
  
  lines.forEach(line => {
    if (line.includes('–ü–∏—Ü—Ü–µ—Ä–∏—è:')) result.pizzeria = line.split(':')[1].trim();
    if (line.includes('–ö–∞—Ç–µ–≥–æ—Ä–∏—è:')) result.category = line.split(':')[1].trim();
    if (line.includes('–ü—Ä–æ–±–ª–µ–º–∞:')) result.problem = line.split(':')[1].trim();
    if (line.includes('–ò–Ω–∏—Ü–∏–∞—Ç–æ—Ä:')) result.initiator = line.split(':')[1].trim();
    if (line.includes('–¢–µ–ª–µ—Ñ–æ–Ω:')) result.phone = line.split(':')[1].trim();
    if (line.includes('–°—Ä–æ–∫:')) result.deadline = line.split(':')[1].trim();
  });
  
  return result;
}

function calculateDelayDays(deadline) {
  if (!deadline) return 0;
  try {
    const deadlineDate = new Date(deadline);
    const today = new Date();
    const diffTime = today - deadlineDate;
    return Math.max(0, Math.ceil(diffTime / (1000 * 60 * 60 * 24)));
  } catch (e) {
    console.error('Error calculating delay:', e);
    return 0;
  }
}

async function sendMessage(chatId, text, options = {}) {
  try {
    return await axios.post(`${TELEGRAM_API}/sendMessage`, {
      chat_id: chatId,
      text,
      parse_mode: 'HTML',
      ...options
    });
  } catch (error) {
    console.error('Send message error:', error.response?.data);
    throw error;
  }
}

async function editMessageSafe(chatId, messageId, text) {
  try {
    return await axios.post(`${TELEGRAM_API}/editMessageText`, {
      chat_id: chatId,
      message_id: messageId,
      text,
      parse_mode: 'HTML'
    });
  } catch (error) {
    if (error.response?.data?.description?.includes('no text in the message') || 
        error.response?.data?.description?.includes('message to edit not found')) {
      return await sendMessage(chatId, text);
    }
    console.error('Edit message error:', error.response?.data);
    throw error;
  }
}

async function sendButtonsWithRetry(chatId, messageId, buttons, fallbackText) {
  try {
    const response = await axios.post(`${TELEGRAM_API}/editMessageReplyMarkup`, {
      chat_id: chatId,
      message_id: messageId,
      reply_markup: { inline_keyboard: buttons }
    });
    return response;
  } catch (error) {
    if (error.response?.data?.description?.includes('not modified')) {
      return { ok: true };
    }
    return await sendMessage(chatId, fallbackText, {
      reply_markup: { inline_keyboard: buttons }
    });
  }
}

async function deleteMessageSafe(chatId, messageId) {
  try {
    return await axios.post(`${TELEGRAM_API}/deleteMessage`, {
      chat_id: chatId,
      message_id: messageId
    });
  } catch (error) {
    console.error('Delete message error:', error.response?.data);
    return null;
  }
}

async function getTelegramFileUrl(fileId) {
  try {
    const { data } = await axios.get(`${TELEGRAM_API}/getFile?file_id=${fileId}`);
    return `${TELEGRAM_FILE_API}/${data.result.file_path}`;
  } catch (error) {
    console.error('Get file URL error:', error.response?.data);
    return null;
  }
}

async function sendToGAS(data) {
  try {
    const response = await axios.post(GAS_WEB_APP_URL, data);
    console.log('Data sent to GAS:', response.status);
    return response.data;
  } catch (error) {
    console.error('Error sending to GAS:', error.message);
    throw error;
  }
}

async function getGoogleDiskLink(row) {
  try {
    const res = await axios.post(`${GAS_WEB_APP_URL}?getDiskLink=true`, { row });
    return res.data.diskLink || null;
  } catch (error) {
    console.error('Get Google Disk link error:', error.response?.data);
    return null;
  }
}

function formatCompletionMessage(data, diskUrl = null) {
  return `
üìå –ó–∞—è–≤–∫–∞ #${data.row} –∑–∞–∫—Ä—ã—Ç–∞.
${diskUrl ? `üìé –§–æ—Ç–æ: ${diskUrl}\n` : data.photoUrl ? `üìé –§–æ—Ç–æ: ${data.photoUrl}\n` : ''}
üí∞ –°—É–º–º–∞: ${data.sum || '0'} —Å—É–º
üë§ –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å: ${data.executor}
‚úÖ –°—Ç–∞—Ç—É—Å: –í—ã–ø–æ–ª–Ω–µ–Ω–æ
${data.delayDays > 0 ? `üî¥ –ü—Ä–æ—Å—Ä–æ—á–∫–∞: ${data.delayDays} –¥–Ω.\n` : ''}
üí¨ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: ${data.comment || '–Ω–µ—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è'}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìç –ó–∞—è–≤–∫–∞ #${data.row}
üè¢ –ü–∏—Ü—Ü–µ—Ä–∏—è: ${data.originalRequest?.pizzeria || '–Ω–µ —É–∫–∞–∑–∞–Ω–æ'}
üìÇ –ö–∞—Ç–µ–≥–æ—Ä–∏—è: ${data.originalRequest?.category || '–Ω–µ —É–∫–∞–∑–∞–Ω–æ'}
üõ† –ü—Ä–æ–±–ª–µ–º–∞: ${data.originalRequest?.problem || '–Ω–µ —É–∫–∞–∑–∞–Ω–æ'}
üôã –ò–Ω–∏—Ü–∏–∞—Ç–æ—Ä: ${data.originalRequest?.initiator || '–Ω–µ —É–∫–∞–∑–∞–Ω–æ'}
${data.originalRequest?.phone ? `üìû –¢–µ–ª–µ—Ñ–æ–Ω: ${data.originalRequest.phone}\n` : ''}
${data.originalRequest?.deadline ? `üïì –°—Ä–æ–∫: ${data.originalRequest.deadline}` : ''}
  `.trim();
}

// –•—Ä–∞–Ω–∏–ª–∏—â–µ user_id
const userStorage = new Map();

module.exports = (app, userStates) => {
  app.post('/webhook', async (req, res) => {
    try {
      const body = req.body;
      
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º user_id –ø—Ä–∏ –ª—é–±–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏
      if (body.message?.from) {
        const user = body.message.from;
        if (user.username) {
          userStorage.set(`@${user.username}`, user.id);
        }
      }

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ callback_query
      if (body.callback_query) {
        const { callback_query } = body;
        const user = callback_query.from;
        
        if (user.username) {
          userStorage.set(`@${user.username}`, user.id);
        }

        if (!callback_query || !callback_query.message || !callback_query.data || !user) {
          return res.sendStatus(200);
        }

        const msg = callback_query.message;
        const chatId = msg.chat.id;
        const messageId = msg.message_id;
        const username = user.username ? `@${user.username}` : null;
        const data = callback_query.data;

        // –û—Ç–≤–µ—Ç –Ω–∞ callback_query
        try {
          await axios.post(`${TELEGRAM_API}/answerCallbackQuery`, {
            callback_query_id: callback_query.id
          });
        } catch (e) {
          console.error('Answer callback error:', e.response?.data);
        }

        // –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –Ω–æ–º–µ—Ä–∞ –∑–∞—è–≤–∫–∏
        const row = extractRowFromCallbackData(data) || extractRowFromMessage(msg.text || msg.caption);
        
        if (!row) {
          console.error('–ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å –Ω–æ–º–µ—Ä –∑–∞—è–≤–∫–∏');
          return res.sendStatus(200);
        }

        console.log('Callback received:', { username, data, row });

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞
        if (!AUTHORIZED_USERS.includes(username)) {
          await sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞.');
          return res.sendStatus(200);
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ "–ü—Ä–∏–Ω—è—Ç—å –≤ —Ä–∞–±–æ—Ç—É"
        if (data === 'accept') {
          if (!MANAGERS.includes(username)) {
            await sendMessage(chatId, '‚ùå –¢–æ–ª—å–∫–æ –º–µ–Ω–µ–¥–∂–µ—Ä—ã –º–æ–≥—É—Ç –Ω–∞–∑–Ω–∞—á–∞—Ç—å –∑–∞—è–≤–∫–∏.');
            return res.sendStatus(200);
          }

          const updatedText = `${msg.text || msg.caption}\n\nüü¢ –ó–∞—è–≤–∫–∞ –≤ —Ä–∞–±–æ—Ç–µ`;
          await editMessageSafe(chatId, messageId, updatedText);

          const buttons = EXECUTORS.map(e => [
            { text: e, callback_data: `executor:${e}:${row}` }
          ]);

          await sendMessage(chatId, `üë∑ –í—ã–±–µ—Ä–∏—Ç–µ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è –¥–ª—è –∑–∞—è–≤–∫–∏ #${row}:`, {
            reply_to_message_id: messageId
          });

          await sendButtonsWithRetry(chatId, messageId, buttons, `–í—ã–±–µ—Ä–∏—Ç–µ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è –¥–ª—è –∑–∞—è–≤–∫–∏ #${row}:`);
          return res.sendStatus(200);
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è
        if (data.startsWith('executor:')) {
          const executorUsername = data.split(':')[1];
          
          // –§–æ—Ä–º–∏—Ä—É–µ–º –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç –¥–ª—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
          const newText = `üìç –ó–∞—è–≤–∫–∞ #${row} –∑–∞–∫—Ä–µ–ø–ª–µ–Ω–∞ –∑–∞ ${executorUsername}\n`
                        + `üü¢ –°—Ç–∞—Ç—É—Å: –í —Ä–∞–±–æ—Ç–µ\n\n`
                        + `üìå –î–µ—Ç–∞–ª–∏ –∑–∞—è–≤–∫–∏:\n`
                        + (msg.text || msg.caption).split('\n').slice(1).join('\n');

          // –†–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
          await editMessageSafe(chatId, messageId, newText);

          // –û–±–Ω–æ–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏
          const buttons = [
            [
              { text: '‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ', callback_data: `done:${row}` },
              { text: 'üïê –û–∂–∏–¥–∞–µ—Ç –ø–æ—Å—Ç–∞–≤–∫–∏', callback_data: `wait:${row}` },
              { text: '‚ùå –û—Ç–º–µ–Ω–∞', callback_data: `cancel:${row}` }
            ]
          ];
          await sendButtonsWithRetry(chatId, messageId, buttons);

          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ (reply –∫ –æ—Å–Ω–æ–≤–Ω–æ–º—É —Å–æ–æ–±—â–µ–Ω–∏—é)
          const notification = await sendMessage(
            chatId,
            `üì¢ ${executorUsername}, –≤–∞–º –Ω–∞–∑–Ω–∞—á–µ–Ω–∞ –∑–∞—è–≤–∫–∞ #${row}!`,
            { reply_to_message_id: messageId }
          );

          // –£–¥–∞–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 1 –º–∏–Ω—É—Ç—É
          setTimeout(async () => {
            try {
              await deleteMessageSafe(chatId, notification.data.result.message_id);
            } catch (e) {
              console.error('–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ:', e);
            }
          }, 60_000);

          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ GAS
          await sendToGAS({
            row,
            status: '–í —Ä–∞–±–æ—Ç–µ',
            executor: executorUsername,
            message_id: messageId,
          });

          return res.sendStatus(200);
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∑–∞—è–≤–∫–∏
        if (data.startsWith('done:')) {
          if (!EXECUTORS.includes(username)) {
            await sendMessage(chatId, '‚ùå –¢–æ–ª—å–∫–æ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–∏ –º–æ–≥—É—Ç –∑–∞–≤–µ—Ä—à–∞—Ç—å –∑–∞—è–≤–∫–∏.');
            return res.sendStatus(200);
          }

          userStates[chatId] = { 
            stage: 'waiting_photo', 
            row: parseInt(data.split(':')[1]), 
            username, 
            messageId,
            originalRequest: parseRequestMessage(msg.text || msg.caption),
            serviceMessages: [] 
          };
          await sendMessage(chatId, 'üì∏ –ü—Ä–∏—à–ª–∏—Ç–µ —Ñ–æ—Ç–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö —Ä–∞–±–æ—Ç');
          return res.sendStatus(200);
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–∂–∏–¥–∞–Ω–∏—è –ø–æ—Å—Ç–∞–≤–∫–∏
        if (data.startsWith('wait:')) {
          if (!EXECUTORS.includes(username)) {
            await sendMessage(chatId, '‚ùå –¢–æ–ª—å–∫–æ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–∏ –º–æ–≥—É—Ç –º–µ–Ω—è—Ç—å —Å—Ç–∞—Ç—É—Å –∑–∞—è–≤–∫–∏.');
            return res.sendStatus(200);
          }

          await sendMessage(chatId, '‚è≥ –ó–∞—è–≤–∫–∞ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–∞ –≤ —Å—Ç–∞—Ç—É—Å "–û–∂–∏–¥–∞–µ—Ç –ø–æ—Å—Ç–∞–≤–∫–∏"', { 
            reply_to_message_id: messageId 
          });
          await sendToGAS({ 
            row: parseInt(data.split(':')[1]), 
            status: '–û–∂–∏–¥–∞–µ—Ç –ø–æ—Å—Ç–∞–≤–∫–∏' 
          });
          return res.sendStatus(200);
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–º–µ–Ω—ã –∑–∞—è–≤–∫–∏
        if (data.startsWith('cancel:')) {
          if (!EXECUTORS.includes(username)) {
            await sendMessage(chatId, '‚ùå –¢–æ–ª—å–∫–æ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–∏ –º–æ–≥—É—Ç –æ—Ç–º–µ–Ω—è—Ç—å –∑–∞—è–≤–∫–∏.');
            return res.sendStatus(200);
          }

          await sendMessage(chatId, 'üö´ –ó–∞—è–≤–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞', { 
            reply_to_message_id: messageId 
          });
          await sendToGAS({ 
            row: parseInt(data.split(':')[1]), 
            status: '–û—Ç–º–µ–Ω–µ–Ω–æ' 
          });
          return res.sendStatus(200);
        }
      }

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±—ã—á–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (–∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∑–∞—è–≤–∫–∏)
      if (body.message) {
        const msg = body.message;
        const chatId = msg.chat.id;
        const state = userStates[chatId];

        if (!state) return res.sendStatus(200);

        try {
          // –≠—Ç–∞–ø 1: –ü–æ–ª—É—á–µ–Ω–∏–µ —Ñ–æ—Ç–æ
          if (state.stage === 'waiting_photo' && msg.photo) {
            const fileId = msg.photo.at(-1).file_id;
            const fileLink = await getTelegramFileUrl(fileId);

            state.photoUrl = fileLink;
            state.stage = 'waiting_sum';
            state.serviceMessages.push(msg.message_id);

            await sendMessage(chatId, 'üí∞ –£–∫–∞–∂–∏—Ç–µ —Å—É–º–º—É —Ä–∞–±–æ—Ç (–≤ —Å—É–º–∞—Ö)');
            return res.sendStatus(200);
          }

          // –≠—Ç–∞–ø 2: –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—É–º–º—ã
          if (state.stage === 'waiting_sum' && msg.text) {
            state.sum = msg.text;
            state.stage = 'waiting_comment';
            state.serviceMessages.push(msg.message_id);

            await sendMessage(chatId, 'üí¨ –ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π');
            return res.sendStatus(200);
          }

          // –≠—Ç–∞–ø 3: –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è –∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ
          if (state.stage === 'waiting_comment' && msg.text) {
            state.comment = msg.text;
            state.serviceMessages.push(msg.message_id);

            const completionData = {
              row: state.row,
              sum: state.sum,
              comment: state.comment,
              photoUrl: state.photoUrl,
              executor: state.username,
              originalRequest: state.originalRequest,
              delayDays: calculateDelayDays(state.originalRequest?.deadline)
            };

            // –û—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –≤ GAS
            await sendToGAS({
              ...completionData,
              status: '–í—ã–ø–æ–ª–Ω–µ–Ω–æ'
            });

            // –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –∏—Ç–æ–≥–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
            const completionMessage = formatCompletionMessage(completionData);
            await editMessageSafe(chatId, state.messageId, completionMessage);

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 3 –º–∏–Ω—É—Ç—ã —Å —Å—Å—ã–ª–∫–æ–π –Ω–∞ Google Disk
            setTimeout(async () => {
              try {
                const diskUrl = await getGoogleDiskLink(state.row);
                if (diskUrl) {
                  const updatedMessage = formatCompletionMessage({
                    ...completionData,
                    photoUrl: diskUrl
                  }, diskUrl);
                  await editMessageSafe(chatId, state.messageId, updatedMessage);
                }
              } catch (e) {
                console.error('Error updating disk link:', e);
              }
            }, 3 * 60 * 1000);

            // –£–¥–∞–ª–µ–Ω–∏–µ —Å–ª—É–∂–µ–±–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π —á–µ—Ä–µ–∑ 1 –º–∏–Ω—É—Ç—É
            setTimeout(async () => {
              try {
                for (const msgId of state.serviceMessages) {
                  await deleteMessageSafe(chatId, msgId);
                }
                // –£–¥–∞–ª—è–µ–º —Å–∞–º–æ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–∞–º–∏
                await deleteMessageSafe(chatId, state.messageId); 
              } catch (e) {
                console.error('Error deleting messages:', e);
              }
            }, 60 * 1000);

            delete userStates[chatId];
            return res.sendStatus(200);
          }
        } catch (e) {
          console.error('Error handling user message:', e);
          return res.sendStatus(500);
        }
      }

      return res.sendStatus(200);
    } catch (error) {
      console.error('Webhook error:', error);
      return res.sendStatus(500);
    }
  });
};
