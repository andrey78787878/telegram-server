// telegram-bot-server.js
const express = require('express');
const axios = require('axios');
const bodyParser = require('body-parser');

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
const app = express();
app.use(bodyParser.json());

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
const BOT_TOKEN = process.env.BOT_TOKEN;
const GAS_WEB_APP_URL = process.env.GAS_WEB_APP_URL;
const TELEGRAM_API = `https://api.telegram.org/bot${BOT_TOKEN}`;

// –°–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
const userStates = {};

// –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
const STATUSES = {
  PENDING: '–≤ –æ—á–µ—Ä–µ–¥–∏',
  IN_PROGRESS: '–í —Ä–∞–±–æ—Ç–µ',
  COMPLETED: '–í—ã–ø–æ–ª–Ω–µ–Ω–æ',
  DELAYED: '–û–∂–∏–¥–∞–µ—Ç –ø–æ—Å—Ç–∞–≤–∫–∏',
  CANCELLED: '–û—Ç–º–µ–Ω–µ–Ω–æ'
};

const EXECUTORS = ['@EvelinaB87', '@Olim19', '@Oblayor_04_09', '–¢–µ–∫—Å—Ç–æ–≤–æ–π –ø–æ–¥—Ä—è–¥—á–∏–∫'];

// –£—Ç–∏–ª–∏—Ç—ã
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

// –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã
const Keyboards = {
  executors: (row) => ({
    inline_keyboard: EXECUTORS.map(executor => [{
      text: executor,
      callback_data: `select_executor:${row}:${encodeURIComponent(executor)}`
    }])
  }),

  actionButtons: (row) => ({
    inline_keyboard: [
      [
        { text: '‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ', callback_data: `complete:${row}` },
        { text: '‚è≥ –û–∂–∏–¥–∞–µ—Ç –ø–æ—Å—Ç–∞–≤–∫–∏', callback_data: `delay:${row}` }
      ],
      [
        { text: '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å', callback_data: `cancel:${row}` }
      ]
    ]
  }),

  delayedButtons: (row) => ({
    inline_keyboard: [
      [
        { text: '‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ', callback_data: `complete:${row}` },
        { text: '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å', callback_data: `cancel:${row}` }
      ]
    ]
  })
};

// Telegram API –º–µ—Ç–æ–¥—ã
const TelegramAPI = {
  sendMessage: async (chatId, text, options = {}) => {
    try {
      const res = await axios.post(`${TELEGRAM_API}/sendMessage`, {
        chat_id: chatId,
        text,
        parse_mode: 'HTML',
        ...options
      });
      return res.data.result;
    } catch (error) {
      console.error('Send message error:', error.response?.data || error.message);
      return null;
    }
  },

  editMessageText: async (chatId, messageId, text, markup) => {
    try {
      await axios.post(`${TELEGRAM_API}/editMessageText`, {
        chat_id: chatId,
        message_id: messageId,
        text,
        parse_mode: 'HTML',
        reply_markup: markup
      });
    } catch (error) {
      console.error('Edit message error:', error.response?.data || error.message);
    }
  },

  answerCallback: async (callbackId, text) => {
    try {
      await axios.post(`${TELEGRAM_API}/answerCallbackQuery`, {
        callback_query_id: callbackId,
        text
      });
    } catch (error) {
      console.error('Answer callback error:', error.response?.data || error.message);
    }
  }
};

// GAS API –º–µ—Ç–æ–¥—ã
const GasAPI = {
  getRequestInfo: async (row) => {
    try {
      const res = await axios.post(GAS_WEB_APP_URL, {
        action: 'getRequestInfo',
        row
      });
      return res.data;
    } catch (error) {
      console.error('GAS request error:', error.response?.data || error.message);
      return null;
    }
  },

  updateStatus: async (row, status, executor = null) => {
    try {
      await axios.post(GAS_WEB_APP_URL, {
        action: 'updateStatus',
        row,
        status,
        ...(executor && { executor })
      });
      return true;
    } catch (error) {
      console.error('GAS update error:', error.response?.data || error.message);
      return false;
    }
  },

  completeRequest: async (row, data) => {
    try {
      await axios.post(GAS_WEB_APP_URL, {
        action: 'complete',
        row,
        ...data
      });
      return true;
    } catch (error) {
      console.error('GAS complete error:', error.response?.data || error.message);
      return false;
    }
  }
};

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏–π
const StateHandlers = {
  handleExecutorSelection: async (chatId, row, executor, messageId) => {
    const decodedExecutor = decodeURIComponent(executor);
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –≤ —Ç–∞–±–ª–∏—Ü–µ
    const success = await GasAPI.updateStatus(row, STATUSES.IN_PROGRESS, decodedExecutor);
    if (!success) return false;

    // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π —Ç–µ–∫—Å—Ç –∑–∞—è–≤–∫–∏
    const requestInfo = await GasAPI.getRequestInfo(row);
    if (!requestInfo) return false;

    // –§–æ—Ä–º–∏—Ä—É–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    const updatedText = `${requestInfo.text}\n\nüü¢ ${STATUSES.IN_PROGRESS}\nüë∑ –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å: ${decodedExecutor}`;

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —á–∞—Ç–µ
    await TelegramAPI.editMessageText(
      chatId,
      messageId,
      updatedText,
      Keyboards.actionButtons(row)
    );

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    userStates[chatId] = {
      row,
      executor: decodedExecutor,
      originalMessageId: messageId,
      stage: 'awaiting_action'
    };

    return true;
  },

  handleComplete: async (chatId, row, messageId) => {
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    userStates[chatId] = {
      row,
      originalMessageId: messageId,
      stage: 'awaiting_photo'
    };

    // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Ñ–æ—Ç–æ
    await TelegramAPI.sendMessage(
      chatId,
      'üì∏ –ü—Ä–∏—à–ª–∏—Ç–µ —Ñ–æ—Ç–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω–æ–π —Ä–∞–±–æ—Ç—ã:',
      { reply_to_message_id: messageId }
    );

    return true;
  },

  handlePhoto: async (chatId, photo, messageId) => {
    const state = userStates[chatId];
    if (!state || state.stage !== 'awaiting_photo') return false;

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ —Ñ–æ—Ç–æ
    state.photoUrl = `https://api.telegram.org/file/bot${BOT_TOKEN}/${photo.file_path}`;
    state.stage = 'awaiting_amount';

    // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Å—É–º–º—É
    await TelegramAPI.sendMessage(
      chatId,
      'üí∞ –í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω–æ–π —Ä–∞–±–æ—Ç—ã:',
      { reply_to_message_id: state.originalMessageId }
    );

    return true;
  },

  handleAmount: async (chatId, amount, messageId) => {
    const state = userStates[chatId];
    if (!state || state.stage !== 'awaiting_amount') return false;

    state.amount = amount;
    state.stage = 'awaiting_comment';

    // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
    await TelegramAPI.sendMessage(
      chatId,
      'üìù –í–≤–µ–¥–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ —Ä–∞–±–æ—Ç–µ:',
      { reply_to_message_id: state.originalMessageId }
    );

    return true;
  },

  finalizeCompletion: async (chatId, comment, messageId) => {
    const state = userStates[chatId];
    if (!state || state.stage !== 'awaiting_comment') return false;

    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–∞—è–≤–∫–µ
    const requestInfo = await GasAPI.getRequestInfo(state.row);
    if (!requestInfo) return false;

    // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Ç–∞–±–ª–∏—Ü–µ
    const completionData = {
      photoUrl: state.photoUrl,
      amount: state.amount,
      comment,
      status: STATUSES.COMPLETED
    };

    const success = await GasAPI.completeRequest(state.row, completionData);
    if (!success) return false;

    // –§–æ—Ä–º–∏—Ä—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    const completedText = `‚úÖ ${STATUSES.COMPLETED}\n\n` +
      `üë∑ –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å: ${state.executor}\n` +
      `üí∞ –°—É–º–º–∞: ${state.amount}\n` +
      `üì∏ –§–æ—Ç–æ: ${state.photoUrl ? '–ø—Ä–∏–ª–æ–∂–µ–Ω–æ' : '–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç'}\n` +
      `üìù –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: ${comment || '–Ω–µ —É–∫–∞–∑–∞–Ω'}\n\n` +
      `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n${requestInfo.text}`;

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    await TelegramAPI.editMessageText(
      chatId,
      state.originalMessageId,
      completedText
    );

    // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    delete userStates[chatId];

    return true;
  }
};

// Webhook –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
app.post('/webhook', async (req, res) => {
  try {
    const { body } = req;
    console.log('Incoming update:', JSON.stringify(body, null, 2));

    // –ë—ã—Å—Ç—Ä—ã–π –æ—Ç–≤–µ—Ç Telegram
    res.sendStatus(200);

    if (body.callback_query) {
      await handleCallback(body.callback_query);
    } else if (body.message) {
      await handleMessage(body.message);
    }
  } catch (error) {
    console.error('Webhook error:', error.stack);
  }
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ callback-–∑–∞–ø—Ä–æ—Å–æ–≤
async function handleCallback(callback) {
  const { data, message, id: callbackId } = callback;
  const chatId = message.chat.id;
  const messageId = message.message_id;

  console.log(`Processing callback: ${data}`);

  // –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –ø–æ–ª—É—á–µ–Ω–∏–µ callback
  await TelegramAPI.answerCallback(callbackId, '–û–±—Ä–∞–±–æ—Ç–∫–∞...');

  const [action, row, ...params] = data.split(':');

  switch (action) {
    case 'select_executor':
      const executor = params[0];
      await StateHandlers.handleExecutorSelection(chatId, row, executor, messageId);
      break;

    case 'complete':
      await StateHandlers.handleComplete(chatId, row, messageId);
      break;

    case 'delay':
      await GasAPI.updateStatus(row, STATUSES.DELAYED);
      await TelegramAPI.editMessageText(
        chatId,
        messageId,
        `${message.text}\n\n‚è≥ ${STATUSES.DELAYED}`,
        Keyboards.delayedButtons(row)
      );
      break;

    case 'cancel':
      await GasAPI.updateStatus(row, STATUSES.CANCELLED);
      await TelegramAPI.editMessageText(
        chatId,
        messageId,
        `${message.text}\n\n‚ùå ${STATUSES.CANCELLED}`
      );
      break;

    default:
      console.warn(`Unknown callback action: ${action}`);
  }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
async function handleMessage(message) {
  const { chat, message_id, text, photo } = message;
  const chatId = chat.id;
  const state = userStates[chatId];

  if (!state) return;

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ç–æ
  if (photo && state.stage === 'awaiting_photo') {
    const fileRes = await axios.get(`${TELEGRAM_API}/getFile?file_id=${photo[photo.length-1].file_id}`);
    await StateHandlers.handlePhoto(chatId, fileRes.data.result, message_id);
    return;
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
  if (text) {
    switch (state.stage) {
      case 'awaiting_amount':
        await StateHandlers.handleAmount(chatId, text, message_id);
        break;

      case 'awaiting_comment':
        await StateHandlers.finalizeCompletion(chatId, text, message_id);
        break;

      default:
        await TelegramAPI.sendMessage(
          chatId,
          '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞—è–≤–∫–∞–º–∏'
        );
    }
  }
}

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Webhook URL: https://yourdomain.com/webhook`);
  console.log(`GAS URL: ${GAS_WEB_APP_URL}`);
});
