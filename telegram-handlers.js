// telegram-handlers.js
module.exports = (app, userStates) => {
  const axios = require('axios');
  const BOT_TOKEN = process.env.BOT_TOKEN;
  const TELEGRAM_API = `https://api.telegram.org/bot${BOT_TOKEN}`;
  const TELEGRAM_FILE_API = `https://api.telegram.org/file/bot${BOT_TOKEN}`;
  const GAS_WEB_APP_URL = process.env.GAS_WEB_APP_URL;

  const EXECUTORS = ['@EvelinaB87', '@Olim19', '@Oblayor_04_09', '–¢–µ–∫—Å—Ç–æ–≤–æ–π –ø–æ–¥—Ä—è–¥—á–∏–∫'];

  function buildExecutorButtons(row) {
    return {
      inline_keyboard: EXECUTORS.map(ex => [
        { text: ex, callback_data: `select_executor:${row}:${ex}` }
      ])
    };
  }

  async function sendMessage(chatId, text, options = {}) {
    const res = await axios.post(`${TELEGRAM_API}/sendMessage`, {
      chat_id: chatId,
      text,
      parse_mode: 'HTML',
      ...options
    });
    return res.data.result.message_id;
  }

  async function editMessageText(chatId, messageId, text, reply_markup) {
    try {
      await axios.post(`${TELEGRAM_API}/editMessageText`, {
        chat_id: chatId,
        message_id: messageId,
        text,
        parse_mode: 'HTML',
        ...(reply_markup && { reply_markup })
      });
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è:', error.message);
    }
  }

  async function deleteMessage(chatId, msgId) {
    try {
      await axios.post(`${TELEGRAM_API}/deleteMessage`, {
        chat_id: chatId,
        message_id: msgId
      });
    } catch (e) {
      console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ:', e.message);
    }
  }

  async function cleanupMessages(chatId, state) {
    const messagesToDelete = [
      ...(state.serviceMessages || []),
      ...(state.userResponses || [])
    ];

    if (messagesToDelete.length) {
      await Promise.all(messagesToDelete.map(msgId =>
        deleteMessage(chatId, msgId).catch(console.error)
      ));
    }
  }

  async function handlePhoto(chatId, photo, state) {
    try {
      const fileRes = await axios.get(`${TELEGRAM_API}/getFile?file_id=${photo[photo.length - 1].file_id}`);
      const filePath = fileRes.data.result.file_path;
      state.photoUrl = `${TELEGRAM_FILE_API}/${filePath}`;

      if (!state.userResponses) state.userResponses = [];
      state.userResponses.push(photo.message_id);

      const prompt = await sendMessage(chatId, 'üí∞ –í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω–æ–π —Ä–∞–±–æ—Ç—ã:');
      state.serviceMessages.push(prompt);
      state.stage = 'awaiting_amount';

    } catch (error) {
      await sendMessage(chatId, '‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–æ—Ç–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.');
    }
  }

  async function handleAmount(chatId, text, messageId, state) {
    try {
      state.amount = text;
      state.userResponses.push(messageId);

      const prompt = await sendMessage(chatId, 'üìù –í–≤–µ–¥–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ —Ä–∞–±–æ—Ç–µ:');
      state.serviceMessages.push(prompt);
      state.stage = 'awaiting_comment';
    } catch (error) {
      await sendMessage(chatId, '‚ö†Ô∏è –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.');
    }
  }

  async function completeRequest(chatId, text, messageId, state) {
    try {
      state.comment = text;
      state.userResponses.push(messageId);

      const originalTextRes = await axios.post(GAS_WEB_APP_URL, {
        action: 'getRequestText',
        row: state.row
      });

      const originalText = originalTextRes.data?.text || '';

      const updatedText = `‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ
üë∑ –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å: ${state.executor}
üí∞ –°—É–º–º–∞: ${state.amount}
üì∏ –§–æ—Ç–æ: ${state.photoUrl}
üìù –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: ${state.comment || '–Ω–µ —É–∫–∞–∑–∞–Ω'}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

${originalText}`;

      await axios.post(GAS_WEB_APP_URL, {
        action: 'complete',
        row: state.row,
        photoUrl: state.photoUrl,
        status: '–í—ã–ø–æ–ª–Ω–µ–Ω–æ',
        amount: state.amount,
        comment: state.comment,
        message_id: state.originalMessageId
      });

      await editMessageText(chatId, state.originalMessageId, updatedText);
      await cleanupMessages(chatId, state);
      delete userStates[chatId];

    } catch (error) {
      await sendMessage(chatId, '‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –∑–∞—è–≤–∫–∏.');
      console.error('–û—à–∏–±–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è:', error);
    }
  }

  app.post('/webhook', async (req, res) => {
    try {
      const body = req.body;

      if (body.callback_query) {
        const { data: raw, message, id: callbackId } = body.callback_query;
        const chatId = message.chat.id;
        const messageId = message.message_id;

        await axios.post(`${TELEGRAM_API}/answerCallbackQuery`, {
          callback_query_id: callbackId
        }).catch(console.error);

        const [action, row, executor] = raw.split(':');

        if (action === 'in_progress') {
          await editMessageText(chatId, messageId, message.text, { inline_keyboard: [] });
          const keyboard = buildExecutorButtons(row);
          const newText = `${message.text}\n\n–í—ã–±–µ—Ä–∏—Ç–µ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è:`;
          await editMessageText(chatId, messageId, newText, keyboard);
          userStates[chatId] = { row, sourceMessageId: messageId, serviceMessages: [] };
          return res.sendStatus(200);
        }

        if (action === 'select_executor') {
          if (!userStates[chatId]) userStates[chatId] = {};

          if (executor === '–¢–µ–∫—Å—Ç–æ–≤–æ–π –ø–æ–¥—Ä—è–¥—á–∏–∫') {
            userStates[chatId].awaiting_manual_executor = true;
            const prompt = await sendMessage(chatId, '–í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø–æ–¥—Ä—è–¥—á–∏–∫–∞:');
            userStates[chatId].serviceMessages.push(prompt);
            return res.sendStatus(200);
          }

          const [originalIdRes, rowDataRes] = await Promise.all([
            axios.post(GAS_WEB_APP_URL, { action: 'getMessageId', row }),
            axios.post(GAS_WEB_APP_URL, { action: 'getRequestRow', row })
          ]);

          const originalMessageId = originalIdRes.data?.message_id;
          const rowData = rowDataRes.data?.row;
          if (!originalMessageId || !rowData) return res.sendStatus(200);

          await axios.post(GAS_WEB_APP_URL, {
            action: 'in_progress',
            row,
            executor,
            message_id: originalMessageId
          });

          const formatDate = (val) => {
            const d = new Date(val);
            return `${String(d.getDate()).padStart(2, '0')}.${String(d.getMonth() + 1).padStart(2, '0')}.${d.getFullYear()}`;
          };

          const updatedText = `üìç –ó–∞—è–≤–∫–∞ #${row}

üçï –ü–∏—Ü—Ü–µ—Ä–∏—è: ${rowData[1] || '‚Äî'}
üîß –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è: ${rowData[2] || '‚Äî'}
üìÇ –ö–∞—Ç–µ–≥–æ—Ä–∏—è: ${rowData[3] || '‚Äî'}
üìã –ü—Ä–æ–±–ª–µ–º–∞: ${rowData[4] || '‚Äî'}
üë§ –ò–Ω–∏—Ü–∏–∞—Ç–æ—Ä: ${rowData[5] || '‚Äî'}
üìû –¢–µ–ª–µ—Ñ–æ–Ω: ${rowData[6] || '‚Äî'}
üïì –°—Ä–æ–∫: ${rowData[8] ? formatDate(rowData[8]) : '‚Äî'}

üü¢ –í —Ä–∞–±–æ—Ç–µ
üë∑ –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å: ${executor}`;

          const buttons = {
            inline_keyboard: [
              [
                { text: '‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ', callback_data: `done:${row}` },
                { text: '‚è≥ –û–∂–∏–¥–∞–µ—Ç –ø–æ—Å—Ç–∞–≤–∫–∏', callback_data: `delayed:${row}` },
                { text: '‚ùå –û—Ç–º–µ–Ω–∞', callback_data: `cancelled:${row}` }
              ]
            ]
          };

          await editMessageText(chatId, originalMessageId, updatedText, buttons);
          if (originalMessageId !== messageId) {
            await editMessageText(chatId, messageId, message.text);
          }

          userStates[chatId] = {
            ...userStates[chatId],
            executor,
            sourceMessageId: originalMessageId,
            originalMessageId
          };

          return res.sendStatus(200);
        }

        if (action === 'done') {
          const originalIdRes = await axios.post(GAS_WEB_APP_URL, {
            action: 'getMessageId',
            row
          });
          const originalMessageId = originalIdRes.data?.message_id;
          if (!originalMessageId) return res.sendStatus(200);

          userStates[chatId] = {
            ...(userStates[chatId] || {}),
            row,
            stage: 'awaiting_photo',
            originalMessageId,
            serviceMessages: [],
            userResponses: []
          };

          const state = userStates[chatId]; // ‚úÖ –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û

          const prompt = await sendMessage(chatId, 'üì∏ –ü—Ä–∏—à–ª–∏—Ç–µ —Ñ–æ—Ç–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è:');
          state.serviceMessages.push(prompt);
          await editMessageText(chatId, originalMessageId, 'üìå –û–∂–∏–¥–∞–µ–º —Ñ–æ—Ç–æ...');
          return res.sendStatus(200);
        }

        if (action === 'delayed') {
          await axios.post(GAS_WEB_APP_URL, { action: 'delayed', row, status: '–û–∂–∏–¥–∞–µ—Ç –ø–æ—Å—Ç–∞–≤–∫–∏' });
          const updatedText = `${message.text}\n\n‚è≥ –û–∂–∏–¥–∞–µ—Ç –ø–æ—Å—Ç–∞–≤–∫–∏`;
          await editMessageText(chatId, messageId, updatedText);
          return res.sendStatus(200);
        }

        if (action === 'cancelled') {
          await axios.post(GAS_WEB_APP_URL, { action: 'cancelled', row, status: '–û—Ç–º–µ–Ω–µ–Ω–æ' });
          const updatedText = `${message.text}\n\n‚ùå –û—Ç–º–µ–Ω–µ–Ω–æ`;
          await editMessageText(chatId, messageId, updatedText);
          return res.sendStatus(200);
        }
      }

      if (body.message) {
        const { chat, message_id, text, photo } = body.message;
        const chatId = chat.id;
        const state = userStates[chatId];
        if (!state) return res.sendStatus(200);

        if (state.awaiting_manual_executor) {
          const [originalIdRes, originalTextRes] = await Promise.all([
            axios.post(GAS_WEB_APP_URL, { action: 'getMessageId', row: state.row }),
            axios.post(GAS_WEB_APP_URL, { action: 'getRequestText', row: state.row })
          ]);

          const originalMessageId = originalIdRes.data?.message_id;
          const originalText = originalTextRes.data?.text || '';
          if (!originalMessageId) return res.sendStatus(200);

          await axios.post(GAS_WEB_APP_URL, {
            action: 'in_progress',
            row: state.row,
            executor: text,
            message_id: originalMessageId
          });

          const updatedText = `${originalText}\n\nüü¢ –í —Ä–∞–±–æ—Ç–µ\nüë∑ –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å: ${text}`;
          const buttons = {
            inline_keyboard: [
              [
                { text: '‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ', callback_data: `done:${state.row}` },
                { text: '‚è≥ –û–∂–∏–¥–∞–µ—Ç –ø–æ—Å—Ç–∞–≤–∫–∏', callback_data: `delayed:${state.row}` },
                { text: '‚ùå –û—Ç–º–µ–Ω–∞', callback_data: `cancelled:${state.row}` }
              ]
            ]
          };

          await editMessageText(chatId, originalMessageId, updatedText, buttons);
          await cleanupMessages(chatId, state);

          userStates[chatId] = {
            ...state,
            executor: text,
            sourceMessageId: originalMessageId,
            originalMessageId,
            awaiting_manual_executor: false
          };

          return res.sendStatus(200);
        }

        if (state.stage === 'awaiting_photo' && photo) {
          await handlePhoto(chatId, photo, state);
          return res.sendStatus(200);
        }

        if (state.stage === 'awaiting_amount') {
          await handleAmount(chatId, text, message_id, state);
          return res.sendStatus(200);
        }

        if (state.stage === 'awaiting_comment') {
          await completeRequest(chatId, text, message_id, state);
          return res.sendStatus(200);
        }

        if (state.stage === 'awaiting_photo' && text) {
          await sendMessage(chatId, '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–∏—à–ª–∏—Ç–µ —Ñ–æ—Ç–æ.');
          return res.sendStatus(200);
        }
      }

      res.sendStatus(200);
    } catch (err) {
      console.error('Webhook error:', err);
      res.sendStatus(500);
    }
  });
};
